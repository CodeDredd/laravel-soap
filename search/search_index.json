{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":":fontawesome-solid-journal-whills: Get started","text":"<p>This package provides an expressive, minimal API around the Soap Client from Phpro, allowing you to quickly make outgoing SOAP requests to communicate with other web applications.</p> <p></p>"},{"location":"#introduction","title":"Introduction","text":"<p>It is using HTTPplug as handler with Guzzle as client. Some code is based/copied on/from Laravel Http wrapper. Thanks for inspiration :-)</p>"},{"location":"#installation","title":"Installation","text":"<p>Package</p> <p>Execute the following command to get the latest version of the package: <pre><code>composer require codedredd/laravel-soap\n</code></pre></p> <p>Configuration</p> <p>Publish Configuration <pre><code>php artisan vendor:publish --provider \"CodeDredd\\Soap\\SoapServiceProvider\"\n</code></pre></p> <p>Code generation feature</p> <p>If you also want to use the code generation feature you have to install following packages: <pre><code>composer require --dev laminas/laminas-code wsdl2phpgenerator/wsdl2phpgenerator\n</code></pre></p>"},{"location":"commands/","title":":fontawesome-solid-journal-whills: Commands","text":"<p>Yes this package comes with some artisan commands to make soap a bit more enjoyable.</p> <p></p>"},{"location":"commands/#requirements","title":"Requirements","text":"<p>You need to install following package to use the code generation feature</p> <pre><code>composer require --dev laminas/laminas-code wsdl2phpgenerator/wsdl2phpgenerator\n</code></pre>"},{"location":"commands/#overview","title":"Overview","text":"Command Description <code>php artisan soap:make:client</code> Create a customized client by wsdl or config name <code>php artisan soap:make:validation</code> Create one or all validation classes by wsdl or config name"},{"location":"commands/#configuration","title":"Configuration","text":"<p>If you have published the configuration file then you have some options for the code generation.</p> Config Default Description <code>code.path</code> <code>app_path('Soap')</code> Define where the generated Code should be saved in your project <code>code.namespace</code> <code>App\\\\Soap</code> Define the namespace of the generated Code"},{"location":"testing/","title":":fontawesome-solid-journal-whills: Testing","text":"<p>Many Laravel services provide functionality to help you easily and expressively write tests,  and this SOAP wrapper is no exception.</p> <p></p>"},{"location":"testing/#faking","title":"Faking","text":"<p>Include <code>use CodeDredd\\Soap\\Facades\\Soap</code> in your testing class. The <code>Soap</code> facade's <code>fake</code> method allows you to instruct the SOAP client to return stubbed / dummy responses  when requests are made.</p>"},{"location":"testing/#fake","title":"fake","text":"<p>Intercepts request with possible given responses</p> <ul> <li><code>Method</code> : <code>function fake($callback = null)</code></li> <li><code>Param</code> : <code>callable|array $callback</code></li> <li><code>Return</code> : <code>\\CodeDredd\\Soap\\SoapFactory</code></li> </ul> <p>Examples with Soap::response</p> simple <p>For returning empty <code>200</code> status code responses for every request, you may call the <code>fake</code> method with no arguments <pre><code>Soap::fake();\n</code></pre></p> with arguments <p>You may pass an array to the <code>fake</code> method. The array's keys should represent ACTION patterns that you wish to fake and their associated responses. The <code>*</code> character may be used as a wildcard character. You may use the <code>response</code> method to construct stub / fake responses for these endpoints <pre><code>Soap::fake([\n    // Stub a JSON response for all Get_ actions...\n    'Get_*' =&gt; Soap::response(['foo' =&gt; 'bar'], 200, ['Headers']),\n\n    // Stub a string response for Submit_User action\n    'Submit_User' =&gt; Soap::response('Hello World', 200, ['Headers']),\n]);\n</code></pre></p> <p>Difference between Laravel Http</p> <p>The difference between Laravels HTTP wrapper is the fact that actions which are not defined in fake are also faked with a default 200 response!</p> overwrite default response <pre><code>Soap::fake([\n    // Stub a JSON response for all Get_ actions...\n    'Get_*' =&gt; Soap::response(['foo' =&gt; 'bar'], 200, ['Headers']),\n\n    // Stub a string response for all other actions\n    '*' =&gt; Soap::response('Hello World', 200, ['Headers']),\n]);\n</code></pre> with callback <p>If you require more complicated logic to determine what responses to return for certain endpoints, you may pass a callback to the <code>fake</code> method. This callback will receive an instance of <code>CodeDredd\\Soap\\Client\\Request</code> and should return a response instance: <pre><code>Soap::fake(function ($request) {\n    return Soap::response('Hello World', 200);\n});\n</code></pre></p> <p>Examples with Soap::sequence</p> simple <p>Sometimes you may need to specify that a single ACTION should return a series of fake responses in a specific order. You may accomplish this by using the <code>Soap::sequence</code> method to build the responses: <pre><code>Soap::fake([\n    // Stub a series of responses for Get_* actions...\n    'Get_*' =&gt; Soap::sequence()\n        -&gt;push('Hello World')\n        -&gt;push(['foo' =&gt; 'bar'])\n        -&gt;pushStatus(404)\n]);\n</code></pre></p> <p>Throws exception if empty</p> <p>When all of the responses in a response sequence have been consumed, any further requests will cause the response sequence to throw an exception!</p> wtih whenEmpty <p>If you would like to specify a default response that should be returned when a sequence is empty, you may use the <code>whenEmpty</code> method <pre><code>Soap::fake([\n    // Stub a series of responses for Get_* actions...\n    'Get_*' =&gt; Soap::sequence()\n        -&gt;push('Hello World')\n        -&gt;push(['foo' =&gt; 'bar'])\n        -&gt;whenEmpty(Soap::response())\n]);\n</code></pre></p>"},{"location":"testing/#response","title":"response","text":"<p>Create a new response instance for use during stubbing (for fake responses)</p> <ul> <li><code>Method</code> : <code>static function response($body = null, $status = 200, $headers = [])</code></li> <li><code>Param</code> : <code>array|string|null $body</code></li> <li><code>Param</code> : <code>int $status</code></li> <li><code>Param</code> : <code>array $headers</code></li> <li><code>Return</code> : <code>\\GuzzleHttp\\Promise\\PromiseInterface</code></li> </ul> <p>When <code>$body</code> is string</p> <p>One important notice. Because a SOAP API doesn't return a single string value every response with only a string in the body is wrapped in an array with key <code>response</code>.</p> <pre><code>[\n    'response' =&gt; 'Hello World'\n]\n</code></pre>"},{"location":"testing/#sequence","title":"sequence","text":"<p>Get an invokable object that returns a sequence of responses in order for use during stubbing</p> <ul> <li><code>Method</code> : <code>function sequence(array $responses = [])</code></li> <li><code>Return</code> : <code>\\CodeDredd\\Soap\\Client\\ResponseSequence</code></li> </ul>"},{"location":"testing/#push","title":"push","text":"<p>Push a response to the sequence.</p> <ul> <li><code>Method</code> : <code>function push($body = '', int $status = 200, array $headers = [])</code></li> <li><code>Return</code> : <code>\\CodeDredd\\Soap\\Client\\ResponseSequence</code></li> </ul>"},{"location":"testing/#pushresponse","title":"pushResponse","text":"<p>Push a response to the sequence.</p> <ul> <li><code>Method</code> : <code>function pushResponse($response)</code></li> <li><code>Param</code> : <code>\\GuzzleHttp\\Promise\\PromiseInterface|\\Closure $response</code></li> <li><code>Return</code> : <code>\\CodeDredd\\Soap\\Client\\ResponseSequence</code></li> </ul>"},{"location":"testing/#pushstatus","title":"pushStatus","text":"<p>Push a response with the given status code to the sequence.</p> <ul> <li><code>Method</code> : <code>function pushStatus(string $filePath, int $status = 200, array $headers = [])</code></li> <li><code>Return</code> : <code>\\CodeDredd\\Soap\\Client\\ResponseSequence</code></li> </ul>"},{"location":"testing/#dontfailwhenempty","title":"dontFailWhenEmpty","text":"<p>Make the sequence return a default response when it is empty.</p> <ul> <li><code>Method</code> : <code>function dontFailWhenEmpty()</code></li> <li><code>Return</code> : <code>\\CodeDredd\\Soap\\Client\\ResponseSequence</code></li> </ul>"},{"location":"testing/#whenempty","title":"whenEmpty","text":"<p>Make the sequence return a custom default response when it is empty.</p> <ul> <li><code>Method</code> : <code>function whenEmpty($response)</code></li> <li><code>Param</code> : <code>\\GuzzleHttp\\Promise\\PromiseInterface|\\Closure $response</code></li> <li><code>Return</code> : <code>\\CodeDredd\\Soap\\Client\\ResponseSequence</code></li> </ul>"},{"location":"testing/#pushfile","title":"pushFile","text":"<p>Push response with the contents of a file as the body to the sequence.</p> <ul> <li><code>Method</code> : <code>function pushFile(int $status = 200, array $headers = [])</code></li> <li><code>Return</code> : <code>\\CodeDredd\\Soap\\Client\\ResponseSequence</code></li> </ul>"},{"location":"testing/#fakesequence","title":"fakeSequence","text":"<p>If you would like to fake a sequence of responses but do not need to specify a specific ACTION pattern that should be faked, you may use the <code>Soap::fakeSequence</code> method.</p> <p>Register a response sequence for the given URL pattern.</p> <ul> <li><code>Method</code> : <code>function fakeSequence(string $url = '*')</code></li> <li><code>Return</code> : <code>\\CodeDredd\\Soap\\Client\\ResponseSequence</code></li> </ul> <p>Example</p> <pre><code>Soap::fakeSequence()\n    -&gt;push('Hello World')\n    -&gt;whenEmpty(Soap::response());\n</code></pre> <p>Tip</p> <p><code>fakeSequence</code> has the same methods as <code>Soap::response</code>. So in most cases <code>fakeSequence</code> will be the better choice to fake response because its an easier and shorter way to define fake responses.</p>"},{"location":"testing/#asserts","title":"Asserts","text":"<p>When faking responses, you may occasionally wish to inspect the requests the client receives in order to make sure your application is sending the correct data or headers.</p>"},{"location":"testing/#assertsent","title":"assertSent","text":"<p>Assert that a request / response pair was recorded matching a given truth test.</p> <ul> <li><code>Method</code> : <code>function assertSent(callable $callback)</code></li> <li><code>Return</code> : <code>void</code></li> </ul> <p>Examples</p> simple <pre><code>Soap::assertSent(function($request){\n    return $request-&gt;action() === 'YourAction'\n});\n</code></pre> with arguments <pre><code>Soap::assertSent(function($request){\n    return $request-&gt;action() === 'YourAction' &amp;&amp;\n        $request-&gt;arguments() === ['argument' =&gt; 'value']\n});\n</code></pre> full <pre><code>Soap::fake();\n\nSoap::baseWsdl('https://test/v1?wsdl')-&gt;call('YourAction', ['argument' =&gt; 'value']);\n\nSoap::assertSent(function($request){\n    return $request-&gt;action() === 'YourAction' &amp;&amp;\n        $request-&gt;arguments() === ['argument' =&gt; 'value']\n});\n</code></pre>"},{"location":"testing/#assertnotsent","title":"assertNotSent","text":"<p>Assert that a request / response pair was not recorded matching a given truth test.</p> <ul> <li><code>Method</code> : <code>function assertNotSent(callable $callback)</code></li> <li><code>Return</code> : <code>void</code></li> </ul> <p>Examples</p> simple <pre><code>Soap::assertNotSent(function($request){\n    return $request-&gt;action() === 'YourAction'\n});\n</code></pre> with arguments <pre><code>Soap::assertNotSent(function($request){\n    return $request-&gt;action() === 'YourAction' &amp;&amp;\n        $request-&gt;arguments() === ['argument' =&gt; 'value']\n});\n</code></pre> full <pre><code>Soap::fake();\n\nSoap::baseWsdl('https://test/v1?wsdl')-&gt;call('YourAction', ['argument' =&gt; 'value']);\n\nSoap::assertNotSent(function($request){\n    return $request-&gt;action() === 'YourAction' &amp;&amp;\n        $request-&gt;arguments() === ['argument' =&gt; 'NotThisValue']\n});\n</code></pre>"},{"location":"testing/#assertactioncalled","title":"assertActionCalled","text":"<p>Assert that a given soap action is called with optional arguments.</p> <ul> <li><code>Method</code> : <code>function assertActionCalled(string $action)</code></li> <li><code>Return</code> : <code>void</code></li> </ul> <p>Examples</p> simple <pre><code>Soap::assertActionCalled('YourAction');\n</code></pre> full <pre><code>Soap::fake();\n\nSoap::baseWsdl('https://test/v1?wsdl')-&gt;call('YourAction');\n\nSoap::assertActionCalled('YourAction');\n</code></pre>"},{"location":"testing/#assertnothingsent","title":"assertNothingSent","text":"<p>Assert that no request / response pair was recorded.</p> <ul> <li><code>Method</code> : <code>function assertNothingSent()</code></li> <li><code>Return</code> : <code>void</code></li> </ul> <p>Examples</p> simple <pre><code>Soap::assertNothingSent();\n</code></pre> full <pre><code>Soap::fake();\n\nSoap::assertNothingSent();\n</code></pre>"},{"location":"testing/#assertsequencesareempty","title":"assertSequencesAreEmpty","text":"<p>Assert that every created response sequence is empty.</p> <ul> <li><code>Method</code> : <code>function assertSequencesAreEmpty()</code></li> <li><code>Return</code> : <code>void</code></li> </ul> <p>Examples</p> simple <pre><code>Soap::assertSequencesAreEmpty();\n</code></pre> full <pre><code>Soap::fake();\n\nSoap::assertSequencesAreEmpty();\n</code></pre>"},{"location":"testing/#assertsentcount","title":"assertSentCount","text":"<p>Assert how many requests have been recorded.</p> <ul> <li><code>Method</code> : <code>function assertSentCount(int $count)</code></li> <li><code>Return</code> : <code>void</code></li> </ul> <p>Examples</p> simple <pre><code>Soap::assertSentCount(3);\n</code></pre> full <pre><code>Soap::fake();\n\n$client = Soap::buildClient('laravlel_soap');\n$response = $client-&gt;call('YourAction');\n$response2 = $client-&gt;call('YourOtherAction');\n\nSoap::assertSentCount(2);\n</code></pre>"},{"location":"testing/#assertsentinorder","title":"assertSentInOrder","text":"<p>Assert that the given request was sent in the given order.</p> <ul> <li><code>Method</code> : <code>function assertSentInOrder($callbacks)</code></li> <li><code>Return</code> : <code>void</code></li> </ul>"},{"location":"client/authentication/","title":"Authentication","text":"<p>You may specify basic authentication credentials using the <code>withBasicAuth</code> method, respectively:</p> <pre><code>// Basic authentication...\n$response = Soap::baseWsdl('http://test.com'/v1?wsdl)-&gt;withBasicAuth('taylor@laravel.com', 'secret')-&gt;call(...);\n</code></pre>"},{"location":"client/authentication/#web-service-security-wss-wsse","title":"Web Service Security (WSS / WSSE)","text":"<p>Internally it is using the wse-php package of robrichards which is a well known library that is used by many developers. It also supports not secured Wsse but with token:</p> <pre><code>//Not secure\n$response = Soap::baseWsdl('http://test.com'/v1?wsdl)-&gt;withWsse([\n    'userTokenName' =&gt; 'username',\n    'userTokenPassword' =&gt; 'password',\n])-&gt;call(...);\n//Secure\n$response = Soap::baseWsdl('http://test.com'/v1?wsdl)-&gt;withWsse([\n    'privateKeyFile' =&gt; 'path/to/privatekey.pem',\n    'publicKeyFile' =&gt; 'path/to/publickey.pyb',\n])-&gt;call(...);\n</code></pre> <p>You have following Wsse Options:</p> <pre><code>'userTokenName' : string\n'userTokenPassword' : string\n'privateKeyFile' : string\n'publicKeyFile' : string\n'serverCertificateFile' : string\n'serverCertificateHasSubjectKeyIdentifier' : boolean\n'userTokenDigest' : boolean\n'digitalSignMethod' : string\n'timestamp' : integer\n'signAllHeaders' =&gt; : boolean\n</code></pre>"},{"location":"client/authentication/#web-service-addressing-wsa","title":"Web Service Addressing (WSA)","text":"<p>Like Wss/Wsse it uses the same package:</p> <pre><code>$response = Soap::baseWsdl(...)\n    -&gt;withWsa()\n    -&gt;call(...)\n</code></pre>"},{"location":"client/authentication/#dhl-cis-authentication","title":"DHL Cis Authentication","text":"<p>DHL uses his own authentication header</p> <pre><code>$client = Soap::withCisDHLAuth('user', 'signature')\n</code></pre>"},{"location":"client/configuration/","title":"Configuration","text":""},{"location":"client/configuration/#soap-client-options","title":"Soap Client Options","text":"<p>You may specify additional Soap request options using the <code>withOptions</code> method. The <code>withOptions</code> method accepts an array of key / value pairs:</p> <pre><code>$response = Soap::baseWsdl(...)-&gt;withOptions([\n    'trace' =&gt; true,\n])-&gt;call(...);\n</code></pre> <p>By default this options are set by the Phpro package:</p> <pre><code>'trace' =&gt; true,\n'exceptions' =&gt; true,\n'keep_alive' =&gt; true,\n'cache_wsdl' =&gt; WSDL_CACHE_DISK, // Avoid memory cache: this causes SegFaults from time to time.\n'features' =&gt; SOAP_SINGLE_ELEMENT_ARRAYS,\n'typemap' =&gt; new TypeConverterCollection([\n    new TypeConverter\\DateTimeTypeConverter(),\n    new TypeConverter\\DateTypeConverter(),\n    new TypeConverter\\DecimalTypeConverter(),\n    new TypeConverter\\DoubleTypeConverter()\n]),\n</code></pre>"},{"location":"client/configuration/#headers","title":"Headers","text":"<p>Headers may be added to requests using the <code>withHeaders</code> method. This <code>withHeaders</code> method accepts an array of key / value pairs:</p> <pre><code>$response = Soap::withHeaders([\n    'X-First' =&gt; 'foo',\n    'X-Second' =&gt; 'bar'\n])-&gt;baseWsdl('http://test.com'/v1?wsdl)-&gt;call('Get_Users');\n</code></pre>"},{"location":"client/configuration/#custom-client-class","title":"Custom Client Class","text":"<p>You are free to extend the SOAP client class used internally by this  package, by defining your own class and extending the package client:</p> <pre><code>use CodeDredd\\Soap\\SoapClient as BaseClient;\n\nclass SoapClient extends BaseClient\n{\n    // ...\n}\n</code></pre> <p>After defining your class, you may instruct the factory to use your  custom class. Typically, this will happen in the <code>boot</code> method of  your application's <code>App\\Providers\\AppServiceProvider</code> class:</p> <pre><code>use App\\Soap\\SoapClient;\nuse CodeDredd\\Soap\\SoapFactory;\n\npublic function boot()\n{\n    SoapFactory::useClientClass(SoapClient::class);\n}\n</code></pre>"},{"location":"client/request/","title":"Request","text":""},{"location":"client/request/#simple-call","title":"Simple call","text":"<p>To make requests, you may use the <code>call</code> method or your soap action through magic <code>__call</code>. First, let's examine how to make a basic <code>action</code> request:</p> <pre><code>use CodeDredd\\Soap\\Facades\\Soap;\n\n$response = Soap::baseWsdl('http://test.com'/v1?wsdl)-&gt;call('Get_Users');\n// Or via magic method call\n$response = Soap::baseWsdl('http://test.com'/v1?wsdl)-&gt;Get_Users();\n</code></pre>"},{"location":"client/request/#call-with-arguments","title":"Call with arguments","text":"<p>Of course, calling a action with arguments is also possible:</p> <pre><code>$response = Soap::baseWsdl('http://test.com'/v1?wsdl)\n    -&gt;call('Submit_User', [\n        'name' =&gt; 'Steve',\n        'role' =&gt; 'Network Administrator',\n    ]);\n// Or via magic method call\n$response = Soap::baseWsdl('http://test.com'/v1?wsdl)\n    -&gt;Submit_User([\n        'name' =&gt; 'Steve',\n        'role' =&gt; 'Network Administrator',\n    ]);\n</code></pre>"},{"location":"client/response/","title":"Response","text":""},{"location":"client/response/#object","title":"Object","text":"<p>The <code>call</code> method returns an instance of <code>CodeDredd\\Soap\\Client\\Response</code>, which provides a variety of methods that may be used to inspect the response:</p> <pre><code>$response-&gt;body() : string;\n$response-&gt;json() : array;\n$response-&gt;status() : int;\n$response-&gt;ok() : bool;\n$response-&gt;successful() : bool;\n$response-&gt;serverError() : bool;\n$response-&gt;clientError() : bool;\n$response-&gt;onError(callable $callback): \\CodeDredd\\Soap\\Client\\Response;\n$response-&gt;collect(): \\Illuminate\\Support\\Collection;\n</code></pre> <p>The <code>CodeDredd\\Soap\\Client\\Response</code> object also implements the PHP <code>ArrayAccess</code> interface, allowing you to access your response data directly on the response:</p> <pre><code>return Soap::baseWsdl('http://test.com'/v1?wsdl)-&gt;call('Get_Users')['name'];\n</code></pre>"},{"location":"client/response/#error-handling","title":"Error Handling","text":"<p>Unlike Guzzle's default behavior, this SOAP client wrapper does not throw exceptions on client or server errors (<code>400</code> and <code>500</code> level responses from servers). You may determine if one of these errors was returned using the <code>successful</code>, <code>clientError</code>, or <code>serverError</code> methods:</p> <pre><code>// Determine if the status code was &gt;= 200 and &lt; 300...\n$response-&gt;successful();\n\n// Determine if the response has a 400 level status code...\n$response-&gt;clientError();\n\n// Determine if the response has a 500 level status code...\n$response-&gt;serverError();\n</code></pre>"},{"location":"client/response/#throwing-exceptions","title":"Throwing Exceptions","text":"<p>If you have a response instance and would like to throw an instance of <code>CodeDredd\\Soap\\Exceptions\\RequestException</code> if the response is a client or server error, you may use the <code>throw</code> method:</p> <pre><code>$response = Soap::baseWsdl(...)-&gt;call(...);\n\n// Throw an exception if a client or server error occurred...\n$response-&gt;throw();\n\nreturn $response['user']['id'];\n</code></pre> <p>The <code>CodeDredd\\Soap\\Exceptions\\RequestException</code> instance has a public <code>$response</code> property which will allow you to inspect the returned response.</p> <p>The <code>throw</code> method returns the response instance if no error occurred, allowing you to chain other operations onto the <code>throw</code> method:</p> <pre><code>return Soap::baseWsdl(...)\n    -&gt;call(...)\n    -&gt;throw()\n    -&gt;json();\n</code></pre>"}]}